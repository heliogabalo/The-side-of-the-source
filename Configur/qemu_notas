################################################################
## PROCESO DE INSTALACION DE UNA IMAGEN
#
# Bien sea porque tenemos el disco original (en este caso un SO windows)
# o bien porque lo hayamos descargado, deberemos antes CREAR una imagen GUEST
# con la que  QEMU, pueda trabajar.
#
# 1.- Para esto primero creamos la imagen. Una "caja" vacía.
# qemu-img create -f qcow2 mi_imagen.img 1G
#
# Aquí el flag "-f" indica el tipo de formato con el que será creada nuestra imagen (aún vacia).
# También indicamos el archivo imagen y el tamaño en Gigabytes.
#
# 2.- Instalación de SUPUESTO OS en la imágen previamente creada:
#
# qemu -m 256 -hda mi_imagen.img -cdrom winxpsp2.iso -boot d
#
# Este comando anterior es un poco confuso.
#   - Habrá que sustituir "qemu" con el comando apropiado, en relación a la arquitectura
#   del sistema operativo GUEST con el que se vaya a trabajar. En este caso sería:
#   qemu-system-i386
#   - Nuevamente el flag -m indica la memoria RAM para el SUPUESTO SO.
#   - La siguiente opción -hda indica el archivo imagen donde vamos a instalar la imagen del SO.
#   - Sigue la opción -cdrom, parece indicar el dispositivo físico un 'CD', pero todo apunta
#   a que se trata de una denominación para diferenciarlo de la partición GUEST que acabamos
#   de crear. Es decir, que utilizaremos el mismo flag '-cdrom' para tratar con una imagen
#   descargada en el disco duro, o una imagen que previamente hayamos 'quemado' en un 'CD'.
#   La diferencia es que para utilizar un 'CD' a la hora de hacer la instalación en nuestra
#   'caja vacía' habrá que indicar la ruta hacia el dispositivo ejem. /dev/cdrom
#   La opción -boot d indica como 'cadena' la letra que será usada en el arranque del sistema.
#   Es exactamente igual a como interpreta la BIOS el 'orden' de arranque de sistema de nuestro 
#   HOST.
#   *  'a' y 'b' para la floppy
#   *  'c' para el disco duro
#   *  'd' para el CD-ROM
#   *  'n-p' arranque desde RED. Opcion muy interesente para un GUEST. Investigar!!!
#   Desde Linux, la cadena que representa el dispositivo de arranque, está muy claro,
#   (pues nosotros no usamos letras para esto). Así que 'c' claramente representa al
#   disco duro y 'd' a un CD-ROM.
#   Desde una perspectiva <Win@> habrá que asegurarse, pués windows utiliza letras para
#   denominar los dispositivos de almacenamiento. De momento a mi plin!
#
#   ------------------------------
## TRABAJAR CON UNA COPIA DE IMAGEN
#
#   La principal idea aquí, es la 'copia de seguridad'. Una vez se ha instalado el sistema
#   operativo, puede trabajarse con una copia de la imagen, resultado de la instalación.#
#   Esto permite probar extensivamente un determinado GUEST, sin importar los cambios que
#   hagamos, pues no serán aplicados al GUEST original, sino a la copia.
#
#   Son necesarios dos pasos básicos:
#
#   1.- Cremaos una imagen 'qemu' con esta funcionalidad:
#
#     <qemu-img create -f qcow2 -o backing_file=winxp.img test01.img 1M>
#
#     Al llamar al 'backing_file' en el proceso de instalación de la image, qemu, parece 
#     no reconocer direcciones fuera del directorio que contiene la imagen 'base'. Esto 
#     quiere decir que para instalar la imagen en el backing file es necesario encontrarse 
#     en el directorio contenedor.
#     nota: mezcla las rutas absolutas/relativas.
#     
#     Con el comando 'backing_file' conseguimos establecer una copia 'base' que no será
#     alterada. Los cambios en el SUPUESTO sólo serán aplicados a la imagen copia.
#     Habrá que tener en cuenta el guardar los cambios aplicados dentro del entorno 
#     alternativo, pues de otro modo, perderemos todo el tabajo cuando borremos la 
#     imagen.
#
#   2.- qemu -m 256 -hda test.img -kernel-kqemu & (obsoleto??)
#     -kemu-qkernel es un parámetro obsoleto no reconocido. He mirado en el Changelog de
#     la version instalada(-v2.6) pero no he encontrado ninguna referencia al respecto.
#     Podría ser que me pasase por alto.
#     Ademas, he tenido que forzar la instalación llamando a la imagen 'base' desde la 
#     linea de comando, igual que si hiciese una instalacion normal.
#
#     Por tanto la línea de entrada quedaría así:
#     qemu-system-i386 -m 256 -hda backing_name.img -cdrom base_name.img -boot <string>
#
#
#
#   
#
#   ------------------------------
#   Notas: 
#     Al seguir éste segundo método de instalación, he podido comprobar que el proceso
#     de conectar el dispositivo y luego montar la unidad GUEST al mismo, lo hace qemu
#     automáticamente, por lo que el uso de los scripts de arranque y parada que he
#     escrito, son poco útiles. Cuidado NO UTILIZAR, para evitar duplicados. 
#
#     Cabe pensar que para el proceso de arranque de una VM, habrá que confeccionar otros
#     scripts específicos, con los que poder dar más opciones al sistema GUEST.
#
#     También es razonable pensar en virtualizar aplicaciones aisladas. Es posible que La
#     Guest solo pueda comunicarse con otra GUEST. Habrá que averiguar si es posible acceder
#     u una partición fuera de VM!!
#
#     Otra idea es probar qemu-ga. Éste es un demonio que funciona desde dentro de la
#     SUPUESTA, así que en teoría, el host via injection/algo puede gestionar la particion
#     de la VM, pero habrá que averiguar que tipo de operaciones puede hacer GUEST-AGENT.
#
#     La idea es mantener la VM simple, ya que por razones obvias, esto mejora su 
#     rendimiento, además el objeto de estas 'maquinas' es romperlas. Y ya se 
#     sabe que pasa cuando uno entra a cuchillo en algún lado(sin saber)...
#     Por otro lado puede que me convenga retomar la programación con Ogre3D. 
#     (en Linux es un DESASTRE!!).
#
#
################################################################
#                  E X P E R I M E N T A L                     #
################################################################
#   
#   VIRTIO -- https://wiki.archlinux.org/index.php/QEMU#qxl
#   
#   virtio-vga / virtio-gpu is a paravirtual 3D graphics driver based on virgl. Currently a work in
#   progress, supporting only very recent (>= 4.4) Linux guests. 
#
# QEMU offers guests the ability to use paravirtualized block and network devices using the virtio
# drivers, which provide better performance and lower overhead.
# 
# A virtio block device requires the option -drive instead of the simple -hd* plus if=virtio:
# 
#     $ qemu-system-i386 -boot order=c -drive file=disk_image,if=virtio
# 
# Note: -boot order=c is absolutely necessary when you want to boot from it. There is no 
# auto-detection as with -hd*.
# 
# Abmos  the same goes for the network:
# 
# $ qemu-system-i386 -net nic,model=virtio
# 
# Note: This will only work if the guest machinethas drivers for virtio devices. Linux does, and the
# required drivers are included in Arch Linux, but there is no guarantee that virtio devices will work
# with other operating systems.
# 
#####################################################################
## Aquí primero preparamos el dispositivo que será leído por el módulo de
## kernel NBD. Para ello debemos tener cargado dicho módulo o cargarlo en 
## todo caso. Recuerda que para llevar a cabo este tipo de operaciones en
#  el kernel debemos escalar privilegios.
#  #
#
# 1- CARGAMOS EL MÓDULO.
#
# rmmod nbd -- Esto carga el módulo de no estar cargado.
# modprobe nbd max_part=16  -- Esto es una opción del módulo que no tengo muy clara, INVESTIGAR. 
# 
# 2.- A continuación preparamos el dispositivo donde montaremos la unidad.
# Este proceso inicia una especie de servidor. Realmente la carga en memoria es mínima, es
# decir, no es como si lanzásemos Apache!!!
#
# qemu-nbd -c /dev/nbd0/ /path/to/vhd_file -- Esto conecta el dispositivo.
# partprobe /dev/nbd0  -- indica al SO los cambios que se han llevado a cabo en la 
#                         tabla de particiones.
#
# 3.- Este último paso, es el que realmente monta la unidad virtual en el sistema.
# 
# mount /dev/nbd0p1 /imagen/a/montar(vhd en este caso!!)
#
#     RECUERDA DESMONTAR LA UNIDAD Y EL DISPOSITIVO CUANDO TERMINES.
#
# umount /imagen/montada(vhd) -- Desmontamos imagen.
# qemu-nbd -d /dev/nbd0 -- desconectamos dispositivo.

################################################################
################################################################

# LANZAR LA VM APUNTANDO AL SERVIDOR NBD
#
# $QEMU -object tls-creds-x509,id=tls0,dir=$HOME/.pki/qemutls,endpoint=client \
#       -drive driver=nbd,host=localhost,port=10809,tls-creds=tls0 \
#       /path/to/img
#



################################################################
################################################################
#
# Por qué convertir imágenes antes de instalarlas:
# 
# qemu-img convert -f source.vhd -O qcow2 destination.qcow2
# 
# - Parece que ha habido algún problemilla con la nomenclatura del comando
# La siguiente devuelve la imagen convertida, sin ningún error desde fd2.
#
#    < qemu-img convert -O qcow2 filename file_output > (autodetectada??)
#
#
# Qemu tiene el conversor de imagenes mas versatil, en relación a otros emuladores.
# Esto lo convierte en una herramienta indispensable a la hora de trabajar con VMs.
# Así como otros emuladores, presentan limitaciones a la hora de trabajar con imagenes
# específicas (extension del archivo) qemu es capaz de interpretar una gran variedad de
# éstas, además de poseer un tipo genérico 'raw' donde converge con otras 'versiones'.
#




################################################################
###############################################################

################################################################
################################################################
## Alternativa cargando en el kernel el módulo NBD de qemu:
## http://bethesignal.org/blog/2011/01/05/how-to-mount-virtualbox-vdi-image/

# modeprobe nbd

## Este comando identifica la imagen, como un dispositivo de bloque llamado
## /dev/nbd0, y la partición dentro de éste, como sub-dispositivo, que sería:
## /dev/nbd0p1

$ qemu-nbd -c /dev/nbd0 <vdi-file> 

## Ahora podríamos ejecutar cfdisk en el dispositivo de bloque, y montarlo
## como partición individual.

# mount /dev/nbd0p1 /mnt -- "/mnt" es el punto de montaje.


## Al terminar podemos desmontar la unidad y el dispositivo, así.

# unmount /mnt
# qemu-nbd -d /dev/nbd0
####################################################################

# You can use qemu-nbd in Linux to access a disk image as if it were a block device.
# Here are some examples of operations that can be performed from a live Knoppix terminal.

#   su 
#   modprobe nbd
#   qemu-nbd --read-only --connect=/dev/nbd0 --format=vpc <vhd_file_name>
#
#   If VHDX format:
#
#   qemu-nbd --connect=/dev/nbd0 --format=VHDX <vhdx_file_name>
#   ddrescue --verbose --force /dev/nbd0 /dev/sda  # write image to /dev/sda
#
## Write one partition:

#   nbd --partition=2 --read-only --connect=/dev/nbd2 --format=vpc <vhd_file_name> 
#   ddrescue --verbose --force /dev/nbd2 /dev/sda2 # write partition 2 of image to /dev/sda2

## Mount partition:
#
#  qemu-nbd --partition=2 --read-only --connect=/dev/nbd2 --format=vpc <vhd_file_name>
#  mount /dev/nbd2 /mnt 
#
## Unmount and disconnect image file:
#
#  umount /mnt 
#  qemu-nbd --disconnect /dev/nbd2
#
## To convert a vhd image to raw (less usable)

qemu-img convert -f raw -O vpc something.img something.vhd

## To convert a vhd image to cow2 (the up to date qemu format)
qemu-img convert -f qcow2 -O vpc something.img something.vhd
